"""Pydantic models for configuration validation."""

from __future__ import annotations

from pathlib import Path
from typing import Any

import yaml
from pydantic import BaseModel, ConfigDict, field_validator

# Config file location
CONFIG_DIR = Path.home() / ".config" / "ops"
CONFIG_FILE = CONFIG_DIR / "config.yaml"


class ProfileConfig(BaseModel):
    """Configuration for a named profile."""

    model_config = ConfigDict(extra="forbid")

    debug: bool = False
    log_level: str = "INFO"

    @field_validator("log_level")
    @classmethod
    def validate_log_level(cls, v: str) -> str:
        """Validate log level is a valid Python logging level."""
        valid = {"DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"}
        upper_v = v.upper()
        if upper_v not in valid:
            raise ValueError(f"Invalid log_level '{v}'. Must be one of: {', '.join(sorted(valid))}")
        return upper_v


class PluginsConfig(BaseModel):
    """Configuration for plugins."""

    model_config = ConfigDict(extra="forbid")

    enabled: list[str] = ["core"]


class SystemConfig(BaseModel):
    """Root configuration model for the system."""

    model_config = ConfigDict(extra="forbid")

    version: str = "1.0"
    environment: str = "development"
    profiles: dict[str, ProfileConfig] = {"default": ProfileConfig()}
    plugins: PluginsConfig = PluginsConfig()

    @field_validator("environment")
    @classmethod
    def validate_environment(cls, v: str) -> str:
        """Validate environment is a known value."""
        valid = {"development", "staging", "production"}
        if v not in valid:
            raise ValueError(
                f"Invalid environment '{v}'. Must be one of: {', '.join(sorted(valid))}"
            )
        return v

    def to_yaml(self) -> str:
        """Convert config to YAML string with comments."""
        data = self.model_dump()
        yaml_content = yaml.dump(data, default_flow_style=False, sort_keys=False)
        header = """# System Control CLI Configuration
# Generated by ops init

"""
        return header + yaml_content


def load_config(config_path: Path | None = None) -> SystemConfig | None:
    """Load and validate configuration from YAML file.

    Args:
        config_path: Path to config file. Defaults to ~/.config/ops/config.yaml

    Returns:
        Validated SystemConfig or None if file doesn't exist.

    Raises:
        ValueError: If config file exists but is invalid.
    """
    path = config_path or CONFIG_FILE

    if not path.exists():
        return None

    try:
        content = path.read_text()
        data: dict[str, Any] = yaml.safe_load(content) or {}
        return SystemConfig.model_validate(data)
    except yaml.YAMLError as e:
        raise ValueError(f"Invalid YAML in {path}: {e}") from e
